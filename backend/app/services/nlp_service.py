"""
NLP Service - EduAutismo IA

OpenAI integration for natural language processing and content generation.
Handles:
- Activity generation
- Progress analysis
- Personalized recommendations
- Content adaptation
"""

import json
import time
from typing import Any, Dict, List, Optional

from app.core.config import settings
from app.core.exceptions import MissingConfigurationError, OpenAIError
from app.utils.constants import (
    DEFAULT_OPENAI_MODEL,
    MAX_TOKENS_ACTIVITY_GENERATION,
    MAX_TOKENS_PROGRESS_ANALYSIS,
    MAX_TOKENS_RECOMMENDATION,
    SYSTEM_PROMPT_ACTIVITY_GENERATION,
    SYSTEM_PROMPT_PROGRESS_ANALYSIS,
    SYSTEM_PROMPT_RECOMMENDATIONS,
    TEMPERATURE_BALANCED,
    TEMPERATURE_CREATIVE,
    TEMPERATURE_PRECISE,
    ActivityType,
    DifficultyLevel,
)
from app.utils.logger import get_logger, log_openai_request
from openai import AsyncOpenAI
from openai import OpenAIError as OpenAIAPIError
from pydantic import BaseModel

logger = get_logger(__name__)


# ============================================================================
# Pydantic Models for Structured Output
# ============================================================================


class GeneratedActivity(BaseModel):
    """Structured activity generated by AI."""

    title: str
    description: str
    objectives: List[str]
    materials: List[str]
    instructions: List[str]
    duration_minutes: int
    adaptations: List[str]
    visual_supports: List[str]
    success_criteria: List[str]


class ProgressAnalysis(BaseModel):
    """Structured progress analysis."""

    summary: str
    strengths: List[str]
    areas_for_improvement: List[str]
    patterns_observed: List[str]
    recommendations: List[str]


class Recommendation(BaseModel):
    """Structured recommendation."""

    title: str
    description: str
    rationale: str
    priority: str  # high, medium, low
    category: str  # activity, strategy, resource


# ============================================================================
# NLP Service Class
# ============================================================================


class NLPService:
    """Service for OpenAI API interactions."""

    def __init__(self):
        """Initialize OpenAI client."""
        if not settings.OPENAI_API_KEY:
            raise MissingConfigurationError("OPENAI_API_KEY")

        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.default_model = DEFAULT_OPENAI_MODEL.value
        logger.info(f"NLPService initialized with model: {self.default_model}")

    async def generate_activity(
        self,
        student_profile: Dict[str, Any],
        activity_type: ActivityType,
        difficulty: DifficultyLevel,
        duration_minutes: int,
        theme: Optional[str] = None,
    ) -> GeneratedActivity:
        """
        Generate personalized activity using AI.

        Args:
            student_profile: Student information (age, interests, learning profile, etc.)
            activity_type: Type of activity to generate
            difficulty: Difficulty level
            duration_minutes: Target duration
            theme: Optional theme/topic

        Returns:
            GeneratedActivity with all details

        Raises:
            OpenAIError: If generation fails
        """
        try:
            start_time = time.time()

            # Build prompt
            prompt = self._build_activity_prompt(
                student_profile=student_profile,
                activity_type=activity_type,
                difficulty=difficulty,
                duration_minutes=duration_minutes,
                theme=theme,
            )

            logger.debug(f"Generating activity: type={activity_type}, difficulty={difficulty}, theme={theme}")

            # Call OpenAI API with structured output
            response = await self.client.chat.completions.create(
                model=self.default_model,
                messages=[
                    {"role": "system", "content": SYSTEM_PROMPT_ACTIVITY_GENERATION},
                    {"role": "user", "content": prompt},
                ],
                temperature=TEMPERATURE_CREATIVE,
                max_tokens=MAX_TOKENS_ACTIVITY_GENERATION,
                response_format={"type": "json_object"},
            )

            # Extract and parse response
            content = response.choices[0].message.content
            activity_data = json.loads(content)

            # Log metrics
            duration_ms = (time.time() - start_time) * 1000
            log_openai_request(
                logger=logger,
                model=self.default_model,
                prompt_tokens=response.usage.prompt_tokens,
                completion_tokens=response.usage.completion_tokens,
                duration_ms=duration_ms,
            )

            # Validate and return structured output
            activity = GeneratedActivity(**activity_data)
            logger.info(f"Activity generated successfully: {activity.title}")

            return activity

        except OpenAIAPIError as e:
            logger.error(f"OpenAI API error: {e}")
            raise OpenAIError(message="Falha ao gerar atividade", original_error=e)

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse OpenAI response: {e}")
            raise OpenAIError(message="Resposta inválida da IA")

        except Exception as e:
            logger.error(f"Unexpected error generating activity: {e}")
            raise OpenAIError(message="Erro inesperado ao gerar atividade", original_error=e)

    async def analyze_progress(
        self,
        student_profile: Dict[str, Any],
        assessments: List[Dict[str, Any]],
        time_period: Optional[str] = None,
    ) -> ProgressAnalysis:
        """
        Analyze student progress using AI.

        Args:
            student_profile: Student information
            assessments: List of assessment records
            time_period: Optional time period (e.g., "last month")

        Returns:
            ProgressAnalysis with insights

        Raises:
            OpenAIError: If analysis fails
        """
        try:
            start_time = time.time()

            # Build prompt
            prompt = self._build_progress_prompt(
                student_profile=student_profile,
                assessments=assessments,
                time_period=time_period,
            )

            logger.debug(f"Analyzing progress for student: {student_profile.get('name', 'Unknown')}")

            # Call OpenAI API
            response = await self.client.chat.completions.create(
                model=self.default_model,
                messages=[
                    {"role": "system", "content": SYSTEM_PROMPT_PROGRESS_ANALYSIS},
                    {"role": "user", "content": prompt},
                ],
                temperature=TEMPERATURE_PRECISE,
                max_tokens=MAX_TOKENS_PROGRESS_ANALYSIS,
                response_format={"type": "json_object"},
            )

            # Extract and parse response
            content = response.choices[0].message.content
            analysis_data = json.loads(content)

            # Log metrics
            duration_ms = (time.time() - start_time) * 1000
            log_openai_request(
                logger=logger,
                model=self.default_model,
                prompt_tokens=response.usage.prompt_tokens,
                completion_tokens=response.usage.completion_tokens,
                duration_ms=duration_ms,
            )

            # Validate and return structured output
            analysis = ProgressAnalysis(**analysis_data)
            logger.info("Progress analysis completed successfully")

            return analysis

        except OpenAIAPIError as e:
            logger.error(f"OpenAI API error: {e}")
            raise OpenAIError(message="Falha ao analisar progresso", original_error=e)

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse OpenAI response: {e}")
            raise OpenAIError(message="Resposta inválida da IA")

        except Exception as e:
            logger.error(f"Unexpected error analyzing progress: {e}")
            raise OpenAIError(message="Erro inesperado ao analisar progresso", original_error=e)

    async def generate_recommendations(
        self,
        student_profile: Dict[str, Any],
        recent_activities: List[Dict[str, Any]],
        progress_summary: Optional[Dict[str, Any]] = None,
    ) -> List[Recommendation]:
        """
        Generate personalized recommendations.

        Args:
            student_profile: Student information
            recent_activities: Recent activity history
            progress_summary: Optional progress analysis

        Returns:
            List of Recommendation objects

        Raises:
            OpenAIError: If generation fails
        """
        try:
            start_time = time.time()

            # Build prompt
            prompt = self._build_recommendations_prompt(
                student_profile=student_profile,
                recent_activities=recent_activities,
                progress_summary=progress_summary,
            )

            logger.debug(f"Generating recommendations for student: {student_profile.get('name', 'Unknown')}")

            # Call OpenAI API
            response = await self.client.chat.completions.create(
                model=self.default_model,
                messages=[
                    {"role": "system", "content": SYSTEM_PROMPT_RECOMMENDATIONS},
                    {"role": "user", "content": prompt},
                ],
                temperature=TEMPERATURE_BALANCED,
                max_tokens=MAX_TOKENS_RECOMMENDATION,
                response_format={"type": "json_object"},
            )

            # Extract and parse response
            content = response.choices[0].message.content
            recommendations_data = json.loads(content)

            # Log metrics
            duration_ms = (time.time() - start_time) * 1000
            log_openai_request(
                logger=logger,
                model=self.default_model,
                prompt_tokens=response.usage.prompt_tokens,
                completion_tokens=response.usage.completion_tokens,
                duration_ms=duration_ms,
            )

            # Parse recommendations
            recommendations = [Recommendation(**rec) for rec in recommendations_data.get("recommendations", [])]
            logger.info(f"Generated {len(recommendations)} recommendations")

            return recommendations

        except OpenAIAPIError as e:
            logger.error(f"OpenAI API error: {e}")
            raise OpenAIError(message="Falha ao gerar recomendações", original_error=e)

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse OpenAI response: {e}")
            raise OpenAIError(message="Resposta inválida da IA")

        except Exception as e:
            logger.error(f"Unexpected error generating recommendations: {e}")
            raise OpenAIError(message="Erro inesperado ao gerar recomendações", original_error=e)

    # ========================================================================
    # Helper Methods - Prompt Building
    # ========================================================================

    def _build_activity_prompt(
        self,
        student_profile: Dict[str, Any],
        activity_type: ActivityType,
        difficulty: DifficultyLevel,
        duration_minutes: int,
        theme: Optional[str] = None,
    ) -> str:
        """Build prompt for activity generation."""
        prompt = f"""Gere uma atividade pedagógica personalizada com as seguintes características:

PERFIL DO ALUNO:
- Nome: {student_profile.get('name', 'Aluno')}
- Idade: {student_profile.get('age', 'não especificada')} anos
- Diagnóstico: {student_profile.get('diagnosis', 'TEA')}
- Interesses: {', '.join(student_profile.get('interests', ['não especificados']))}
- Pontos fortes: {', '.join(student_profile.get('strengths', ['a identificar']))}
- Desafios: {', '.join(student_profile.get('challenges', ['a identificar']))}

REQUISITOS DA ATIVIDADE:
- Tipo: {activity_type.value}
- Nível de dificuldade: {difficulty.value}
- Duração estimada: {duration_minutes} minutos
"""
        if theme:
            prompt += f"- Tema: {theme}\n"

        prompt += """
Retorne a atividade no seguinte formato JSON:
{
    "title": "Título da atividade",
    "description": "Descrição detalhada",
    "objectives": ["Objetivo 1", "Objetivo 2", ...],
    "materials": ["Material 1", "Material 2", ...],
    "instructions": ["Passo 1", "Passo 2", ...],
    "duration_minutes": 30,
    "adaptations": ["Adaptação 1", "Adaptação 2", ...],
    "visual_supports": ["Suporte visual 1", "Suporte visual 2", ...],
    "success_criteria": ["Critério 1", "Critério 2", ...]
}

IMPORTANTE:
- A atividade deve ser clara, estruturada e motivadora
- Incorpore os interesses do aluno sempre que possível
- Inclua instruções visuais e suportes necessários
- As adaptações devem considerar os desafios específicos
- Os critérios de sucesso devem ser observáveis e mensuráveis
"""
        return prompt

    def _build_progress_prompt(
        self,
        student_profile: Dict[str, Any],
        assessments: List[Dict[str, Any]],
        time_period: Optional[str] = None,
    ) -> str:
        """Build prompt for progress analysis."""
        period_text = f" no período: {time_period}" if time_period else ""

        prompt = f"""Analise o progresso do aluno{period_text}.

PERFIL DO ALUNO:
- Nome: {student_profile.get('name', 'Aluno')}
- Idade: {student_profile.get('age', 'não especificada')} anos
- Diagnóstico: {student_profile.get('diagnosis', 'TEA')}

AVALIAÇÕES ({len(assessments)} registros):
"""
        # Add assessment summaries
        for i, assessment in enumerate(assessments[:10], 1):  # Limit to 10 most recent
            prompt += f"""
Avaliação {i}:
- Atividade: {assessment.get('activity_title', 'Não especificada')}
- Status: {assessment.get('completion_status', 'N/A')}
- Engajamento: {assessment.get('engagement_level', 'N/A')}
- Dificuldade percebida: {assessment.get('difficulty_rating', 'N/A')}
- Observações: {assessment.get('notes', 'Nenhuma')}
"""

        prompt += """
Retorne a análise no seguinte formato JSON:
{
    "summary": "Resumo geral do progresso",
    "strengths": ["Ponto forte 1", "Ponto forte 2", ...],
    "areas_for_improvement": ["Área 1", "Área 2", ...],
    "patterns_observed": ["Padrão 1", "Padrão 2", ...],
    "recommendations": ["Recomendação 1", "Recomendação 2", ...]
}

Seja específico, construtivo e baseado em evidências das avaliações fornecidas.
"""
        return prompt

    def _build_recommendations_prompt(
        self,
        student_profile: Dict[str, Any],
        recent_activities: List[Dict[str, Any]],
        progress_summary: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Build prompt for recommendations."""
        prompt = f"""Gere recomendações personalizadas para o aluno.

PERFIL DO ALUNO:
- Nome: {student_profile.get('name', 'Aluno')}
- Idade: {student_profile.get('age', 'não especificada')} anos
- Diagnóstico: {student_profile.get('diagnosis', 'TEA')}
- Interesses: {', '.join(student_profile.get('interests', ['não especificados']))}

ATIVIDADES RECENTES:
"""
        for i, activity in enumerate(recent_activities[:5], 1):
            prompt += f"- {activity.get('title', 'Atividade')} ({activity.get('type', 'N/A')})\n"

        if progress_summary:
            prompt += f"\nRESUMO DE PROGRESSO:\n{progress_summary.get('summary', 'Não disponível')}\n"

        prompt += """
Retorne as recomendações no seguinte formato JSON:
{
    "recommendations": [
        {
            "title": "Título da recomendação",
            "description": "Descrição detalhada",
            "rationale": "Justificativa baseada no perfil/progresso",
            "priority": "high|medium|low",
            "category": "activity|strategy|resource"
        },
        ...
    ]
}

Gere 3-5 recomendações práticas e acionáveis, priorizando as mais relevantes.
"""
        return prompt

    # ========================================================================
    # Utility Methods
    # ========================================================================

    async def test_connection(self) -> bool:
        """
        Test OpenAI API connection.

        Returns:
            True if connection is successful

        Raises:
            OpenAIError: If connection fails
        """
        try:
            response = await self.client.chat.completions.create(
                model=self.default_model,
                messages=[{"role": "user", "content": "Test connection"}],
                max_tokens=5,
            )
            logger.info("OpenAI connection test successful")
            return True

        except OpenAIAPIError as e:
            logger.error(f"OpenAI connection test failed: {e}")
            raise OpenAIError(message="Falha ao conectar com OpenAI", original_error=e)


# ============================================================================
# Global Service Instance
# ============================================================================

# Singleton instance
_nlp_service: Optional[NLPService] = None


def get_nlp_service() -> NLPService:
    """
    Get global NLP service instance.

    Returns:
        NLPService instance

    Raises:
        MissingConfigurationError: If OpenAI API key is not configured
    """
    global _nlp_service

    if _nlp_service is None:
        _nlp_service = NLPService()

    return _nlp_service


async def health_check_nlp() -> Dict[str, Any]:
    """
    Health check for NLP service.

    Returns:
        Health status dictionary
    """
    try:
        service = get_nlp_service()
        start_time = time.time()
        await service.test_connection()
        latency_ms = (time.time() - start_time) * 1000

        return {
            "status": "up",
            "latency_ms": round(latency_ms, 2),
            "model": service.default_model,
        }

    except Exception as e:
        logger.error(f"NLP health check failed: {e}")
        return {
            "status": "down",
            "error": str(e),
        }
